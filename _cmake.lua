--
-- _cmake.lua
-- Define the makefile action(s).
-- Copyright (c) 2014 Manu Evans and the Premake project
--

	premake.extensions.cmake = {}

	local cmake = premake.extensions.cmake
	local solution = premake.solution
	local project = premake.project


---
-- The CMake action, with support for the new platforms API
---

	newaction {
		trigger         = "cmake",
		shortname       = "CMake",
		description     = "Generate CMake files",

		valid_kinds     = { "ConsoleApp", "WindowedApp", "StaticLib", "SharedLib" },

		valid_languages = { "C", "C++", "C#", "D" },

		valid_tools     = {
			cc     = { "msc", "clang", "gcc" },
			dc     = { "dmd", "gdc", "ldc" },
			dotnet = { "mono", "msnet", "pnet" }
		},

		onsolution = function(sln)
			premake.escaper(cmake.esc)
			premake.generate(sln, cmake.getmakefilename(sln, false), cmake.generate_solution)
		end,

		onproject = function(prj)
			premake.escaper(cmake.esc)
			local cmakefile = cmake.getcmakefilename(prj, true)
			if project.isdotnet(prj) then
				premake.generate(prj, cmakefile, cmake.cs.generate)
			elseif project.isd(prj) then
				premake.generate(prj, cmakefile, cmake.d.generate)
			elseif project.iscpp(prj) then
				premake.generate(prj, cmakefile, cmake.cpp.generate)
			end
		end,

		oncleansolution = function(sln)
			premake.clean.file(sln, cmake.getcmakefilename(sln, false))
		end,

		oncleanproject = function(prj)
			premake.clean.file(prj, cmake.getcmakefilename(prj, true))
		end
	}


--
-- Write out the default configuration rule for a solution or project.
-- @param target
--    The solution or project object for which a cmake file is being generated.
--

	function cmake.defaultconfig(target)
		-- find the right configuration iterator function for this object
		local eachconfig = iif(target.project, project.eachconfig, solution.eachconfig)
		local iter = eachconfig(target)

		-- grab the first configuration and write the block
		local cfg = iter()
		if cfg then
			_p('ifndef config')
			_x('  config=%s', cfg.shortname)
			_p('endif')
			_p('')
		end
	end


---
-- Escape a string so it can be written to a cmake file.
---

	function cmake.esc(value)
--		result = value:gsub("\\", "\\\\")
--		result = result:gsub(" ", "\\ ")
--		result = result:gsub("%(", "\\%(")
--		result = result:gsub("%)", "\\%)")

		-- leave $(...) shell replacement sequences alone
--		result = result:gsub("$\\%((.-)\\%)", "$%(%1%)")
--		return result
		return value
	end


--
-- Get the cmake file name for a solution or a project. If this object is the
-- only one writing to a location then I can use "cmakelist.txt". If more than one object
-- writes to the same location I use name + ".???" to keep it unique.
--

	function cmake.getcmakefilename(this, searchprjs)
		local count = 0
		for sln in premake.solution.each() do
			if sln.location == this.location then
				count = count + 1
			end

			if searchprjs then
				for _, prj in ipairs(sln.projects) do
					if prj.location == this.location then
						count = count + 1
					end
				end
			end
		end

		if count == 1 then
			return "cmakelist.txt"
		else
			return ".txt"
		end
	end


--
-- Output a cmake file header.
--
-- @param target
--    The solution or project object for which the cmake file is being generated.
--

	function cmake.header(target)
		-- find the right configuration iterator function for this object
		local kind = iif(target.project, "project", "solution")

		_p('# %s %s CMake autogenerated by Premake', premake.action.current().shortname, kind)
		_p('')

		cmake.defaultconfig(target)

		_p('ifndef verbose')
		_p('  SILENT = @')
		_p('endif')
		_p('')
	end


--
-- Rules for file ops based on the shell type. Can't use defines and $@ because
-- it screws up the escaping of spaces and parethesis (anyone know a solution?)
--

	function cmake.mkdirRules(dirname)
		_p('%s:', dirname)
		_p('\t@echo Creating %s', dirname)
		_p('ifeq (posix,$(SHELLTYPE))')
		_p('\t$(SILENT) mkdir -p %s', dirname)
		_p('else')
		_p('\t$(SILENT) mkdir $(subst /,\\\\,%s)', dirname)
		_p('endif')
		_p('')
	end


--
-- Format a list of values to be safely written as part of a variable assignment.
--

	function cmake.list(value)
		if #value > 0 then
			return " " .. table.concat(value, " ")
		else
			return ""
		end
	end


--
-- Convert an arbitrary string (project name) to a cmake variable name.
--

	function cmake.tovar(value)
		value = value:gsub("[ -]", "_")
		value = value:gsub("[()]", "")
		return value
	end


---------------------------------------------------------------------------
--
-- Handlers for the individual cmake file elements that can be shared
-- between the different language projects.
--
---------------------------------------------------------------------------

	function cmake.objdir(cfg)
		_x('  OBJDIR = %s', project.getrelative(cfg.project, cfg.objdir))
	end


	function cmake.objDirRules(prj)
		cmake.mkdirRules("$(OBJDIR)")
	end


	function cmake.phonyRules(prj)
		_p('.PHONY: clean prebuild prelink')
		_p('')
	end


	function cmake.buildCmds(cfg, event)
		_p('  define %sCMDS', event:upper())
		local steps = cfg[event .. "commands"]
		local msg = cfg[event .. "message"]
		if #steps > 0 then
			msg = msg or string.format("Running %s commands", event)
			_p('\t@echo %s', msg)
			_p('\t%s', table.implode(steps, "", "", "\n\t"))
		end
		_p('  endef')
	end


	function cmake.preBuildCmds(cfg, toolset)
		cmake.buildCmds(cfg, "prebuild")
	end


	function cmake.preBuildRules(prj)
		_p('prebuild:')
		_p('\t$(PREBUILDCMDS)')
		_p('')
	end


	function cmake.preLinkCmds(cfg, toolset)
		cmake.buildCmds(cfg, "prelink")
	end


	function cmake.preLinkRules(prj)
		_p('prelink:')
		_p('\t$(PRELINKCMDS)')
		_p('')
	end


	function cmake.postBuildCmds(cfg, toolset)
		cmake.buildCmds(cfg, "postbuild")
	end


	function cmake.settings(cfg, toolset)
		if #cfg.cmakesettings > 0 then
			for _, value in ipairs(cfg.cmakesettings) do
				_p(value)
			end
		end

		local value = toolset.getcmakesettings(cfg)
		if value then
			_p(value)
		end
	end


	function cmake.shellType()
		_p('SHELLTYPE := msdos')
		_p('ifeq (,$(ComSpec)$(COMSPEC))')
		_p('  SHELLTYPE := posix')
		_p('endif')
		_p('ifeq (/bin,$(findstring /bin,$(SHELL)))')
		_p('  SHELLTYPE := posix')
		_p('endif')
		_p('')
	end


	function cmake.target(cfg)
		_x('  TARGETDIR = %s', project.getrelative(cfg.project, cfg.buildtarget.directory))
		_x('  TARGET = $(TARGETDIR)/%s', cfg.buildtarget.name)
	end


	function cmake.targetDirRules(prj)
		cmake.mkdirRules("$(TARGETDIR)")
	end
